
I have created a plaintext file and run a few simple regexps through my solution and attach a compressed archive of these here. [You can unpack this archive on Linux with "% tar xvf REexamples.gz" which runs the old standard tape archive program "tar" with flags to x expand v verbosely f thisArchiveFile.]   Note that I use State 0 as the default start (as per lectures) and it just branches to whatever state turns out to be the actual start.  Note also that I use a branch state as my final state but with both next states being -1, which my searcher uses as a flag to say it made it to the final state.  I don't think we talked about this in lecture too much, so if your searcher uses a different strategy to mark the final state then that's fine.  And, finally, note that I use a dummy final state for FSMs in alternation, just to bring them all together at one common final state before moving on.  I did talk about this in lecture, but it may not have been abundantly clear, and students can use any strategy they want to unify the final states of machines in disjunction.  I find this a little easier than tring to fix the last state in each FSM individually ... especially when three or four or more machines are alternatives wink

I'll try and make some more, slightly more complicated, examples and post them here.  I have placed this in the Discussion Forum in the event it makes it easier for people to discuss what I have put here, and what different partnerships are doing to solve problems.  I encourage everyone to talk to partners and to fellow students .... you can discuss strategies and approaches ... ust don't share code (except with your partner).

Enjoy.