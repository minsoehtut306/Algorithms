NP-hard problems are decidable problems for which no polynomial time algorithm is known. A subset of these, known as NP-complete, are fundamentally all the same, such that if a polynomial time solution was found for one then it could be transformed (in polynomial time) to solve any of the others. The so-called k satisfiability problem is the first one entered into the NPC class, where k boolean values must be found that produce a given truth value for a boolean function with k inputs/parameters.

Many NP-hard problems exist for which finding a solution is desirable but intractable.  Typically, one must be satisfied with a solution that may not be optimal, but which is at least pretty good.  One approach is to simply to generate and test random candidate solution  and keep the best one.  This is possible when candidate solutions can be evaluated and compared. E.g. ...

subset selection - given a set of X numeric values, partition it into two subsets whose total values have minimum difference.  Since there are 2N possible subsets for N values, and no obvious way to find one that satisfies the objective except by looking at every possible solution, this problem appears to be NP-hard (and is, in fact, NPComplete).  A potential solution can be generated using a random number less than 2N  where the set bits select one subset and the clear bits the other subset.  This solution can be evaluated by computing the difference in the value of the two susbets.  The smaller the difference, the better.  Candidate solutions can be compared with that evaluation function, and progress can be made by always keeping the solution with the best evaluation, continuing to generate & test new solutions randomly until time runs out.



heuristic - a guiding principle to aid in solving a problem, not guaranteed to solve it

Some NP-hard problems have properties that allow us to guide our search for a good solution in a more principled way than just randomly generating candidate solutions.  For example, the box-stacking problem (i.e. finding a subset of boxes that can be stacked in accordance with certain constraints so as to produce the tallest stack) might be approached by thinking of a stack as being made up of sub-stacks ... like, a bottom half and a top half.  Solving two exponentially hard problems of size N/2 is a lot easier than solving one exponential problem of size N; although constraints for combining the two sub-solutions into one final solution may preclude finding the global optimum.

Given a problem where a rule-of-thumb principle might help, there are a number of programming techniques that can help find pretty good solutions more effectively and efficiently than random probes into the solution space.  We call these "heuristic methods".

General heuristic methods:

generate & test - repeatedly generate potential solutions, evaluate them, always keep the best found so far, stop when resources run out
hill-climbing - generate one solution and repeatedly make a small random change, always keeping any change that improves the solution, stop when no more changes improve the solution
simulated annealing - generate a solution, makes lots of random changes, keep any that improve the solution, continue doing this but reduce the number of changes as time runs out, ultimately becoming hill-climbing.  The number of changes made is called the temperature and the rate at which the number of changes diminishes is called cooling (n.b. the whole process is said to be analogous to actual annealing ... used to toughen physical materials, like steel).
genetic algorithm - generate an initial population of solutions, then ... evaluate individuals in the population, choose two to mate based proportionately on their fitness (i.e. how good they are) and create offspring by combining aspects of the two, optionally choose a solution and mutate it with some random change, kill off (i.e. throw away, cull) some of the individuals to keep population size constant.  Repeat breeding, mutating, culling until resources run out and then proffer the best in the final population as the overall solution.  In some variations, more than one couple can be allowed to create offspring during the breeding cycle, more than one individual may be mutated, and the population might be allowed to grow for a time before culling.  The key components are: a population of solutions, offspring created from members of the population, some (typically little) mutation, and culling.